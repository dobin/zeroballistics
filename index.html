<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.24.1/dist/phaser-arcade-physics.min.js"></script>
    <script src="https://labs.phaser.io/js/datgui.js"></script>
    <script src="gui.js"></script>
    <script src="gfxentities.js"></script>
    <script src="staticdata.js"></script>
    <script src="draw.js"></script>
</head>
<body>

<script>
// Static Config
var config = {
    type: Phaser.AUTO,
    width: 1440,
    height: 800,
    //backgroundColor: '#788878',
    backgroundColor: '#708e72',
    parent: 'phaser-example',
    scene: {
        preload: preload,
        create: create,
        update: update,
    },

    offset: -84,
    reticleOffsetX: 10000,  // at 100m
    recicleOffsetY: -600,
};

// The game
var game = null;
var graphics = null;

// Runtime Data
var data = {
    gfxGroup: [],

    lineLos: null,
    lineExps: null,
    lineRing1: null,
    lineRing2: null,

    trajCurves: null,

    points: [],
    showDebug: false,

    reticleEnemy: null,
    reticleEnemyScale: 1.0,

    trajImpactShow: false,
    trajImpactX: 0,
    trajImpactY: 0,
};


// Start here
window.onload = function() {
    initGui();
    new Phaser.Game(config);
    document.getElementsByTagName("canvas").item(0).oncontextmenu = function(e) { e.preventDefault(); e.stopPropagation(); }
};


// Phaser Preload
function preload ()
{
    this.load.image('lemming', '17966.png');
    this.load.image('enemy', '321184.png');
}

// Phaser Create
function create()
{
    game = this;
    createGfx(); 

    /* zoom */
    this.cameras.main.zoom = 0.5;
    this.cameras.main.centerOnY(-400);
    this.cameras.main.centerOnX(1100);

    this.input.on('wheel', (pointer, gameObjects, deltaX, deltaY, deltaZ) => {
        //this.cameras.main.centerOn(pointer.worldX, pointer.worldY);

        z = this.cameras.main.zoom;
        if (deltaY < 0) {
            this.cameras.main.zoom += (z/2);
        } else {
            this.cameras.main.zoom -= (z/2);
        }
    });
}


// Phaser: Update
function update(time, delta)
{
    if (this.reload) {
        this.gfxGroup.forEach(function (item, index) {
            item.destroy();
        });
        createGfx(this);
        this.reload = false;
    }

    handleZoom(this);

    graphics.clear();
    drawLines(graphics);
    drawReticle(graphics);
}


function handleZoom(tt) {
    z = tt.cameras.main.zoom;

    // https://www.html5gamedevs.com/topic/9814-move-camera-by-dragging-the-world-floor/
    // Dragging camera
    if (tt.game.input.activePointer.isDown) {
        if (tt.game.origDragPoint) {
            // move the camera by the amount the mouse has moved since last update
            var sX = tt.game.origDragPoint.x - tt.game.input.activePointer.position.x;
            var sY = tt.game.origDragPoint.y - tt.game.input.activePointer.position.y;

            tt.cameras.main.scrollX += sX / z;
            tt.cameras.main.scrollY += sY / z;
                
        } // set new drag origin to current position
        tt.game.origDragPoint = tt.game.input.activePointer.position.clone();
    } else {
        tt.game.origDragPoint = null;
    }
}


/**************************************/

function resetGfx() {
    data.gfxGroup.forEach(function (item, index) {
            item.destroy();
        });
    createGfx();
}

function createGfx() {
    data.gfxGroup = [];

    gfxCreateCharacters();
    gfxCreateReticleEnemy();
    gfxCreateHeight();
    gfxCreateDotTwo();
    gfxCreateRing();
    gfxCreateTrajectories();

    /* IMPORTANT to have it here */
    if (graphics != null) {
        graphics.destroy();
    }
    graphics = game.add.graphics();
    graphics.z = 1;
}


</script>

</body>
</html>