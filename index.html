<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.24.1/dist/phaser-arcade-physics.min.js"></script>
    <script src="https://labs.phaser.io/js/datgui.js"></script>
    <script src="gui.js"></script>
    <script src="gfxentities.js"></script>
    <script src="staticdata.js"></script>
</head>
<body>

<script>
// Static Config
var config = {
    type: Phaser.AUTO,
    width: 1440,
    height: 800,
    backgroundColor: '#010101',
    parent: 'phaser-example',
    scene: {
        preload: preload,
        create: create,
        update: update
    },

    offset: -50,
};

// The game
var game = null;

// Runtime Data
var data = {
    gfxGroup: [],

    lineLos: null,
    lineExps: null,
    lineRing1: null,
    lineRing2: null,

    trajCurves: null,

    points: [],
    showDebug: false,
};


// Start here
window.onload = function() {
    initGui();
    new Phaser.Game(config);
};


// Phaser Preload
function preload ()
{
    //this.load.image('lemming', 'assets/sprites/lemming.png');
    //this.load.spritesheet('dragcircle', 'assets/sprites/dragcircle.png', { frameWidth: 16 });

}

// Phaser Create
function create()
{
    game = this;
    graphics = this.add.graphics();
    this.cameras.main.zoom = 0.5;
    createGfx();
    this.cameras.main.centerOnY(-400);
    this.cameras.main.centerOnX(1100);

    /* zoom */
    this.input.on('wheel', (pointer, gameObjects, deltaX, deltaY, deltaZ) => {
        //this.cameras.main.centerOn(pointer.worldX, pointer.worldY);

        z = this.cameras.main.zoom;
        if (deltaY < 0) {
            this.cameras.main.zoom += (z/2);
        } else {
            this.cameras.main.zoom -= (z/2);
        }
        //this.cameras.main.centerToBounds();
        //
        //
    });
}

// Phaser: Update
function update(time, delta)
{
    if (this.reload) {
        this.gfxGroup.forEach(function (item, index) {
            item.destroy();
        });
        createGfx(this);
        this.reload = false;
    }

    handleZoom(this);

    graphics.clear();
    drawLines(graphics);
}


function handleZoom(tt) {
    z = tt.cameras.main.zoom;

    // https://www.html5gamedevs.com/topic/9814-move-camera-by-dragging-the-world-floor/
    // Dragging camera
    if (tt.game.input.activePointer.isDown) {
        if (tt.game.origDragPoint) {
            // move the camera by the amount the mouse has moved since last update
            var sX = tt.game.origDragPoint.x - tt.game.input.activePointer.position.x;
            var sY = tt.game.origDragPoint.y - tt.game.input.activePointer.position.y;

            tt.cameras.main.scrollX += sX / z;
            tt.cameras.main.scrollY += sY / z;
                
        } // set new drag origin to current position
        tt.game.origDragPoint = tt.game.input.activePointer.position.clone();
    } else {
        tt.game.origDragPoint = null;
    }
}


/**************************************/

function resetGfx() {
    data.gfxGroup.forEach(function (item, index) {
            item.destroy();
        });
    createGfx();
}

function createGfx() {
    data.gfxGroup = [];

    if (uiConfig.showEnemies) {
        enemyLocations.forEach(function (item, index) {
            if (item == 10 && !uiConfig.show10m) {
                return;
            }
            makeEnemy(item);
            if (item > 0) {
                makeNr(item);
            }
        }.bind(this));
    }

    // height
    data.gfxGroup.push(game.add.rectangle(
        -200, 0, // xy
        4, 200,  // width, height
        0xffffff));
    data.gfxGroup.push(game.add.text(
        -250, 110, 
        "2m").setScale(6));

    // Line of sight
    if (uiConfig.showLos) {
        data.lineLos = new Phaser.Geom.Line(
            0, config.offset, 
            uiConfig.scale * (60000), config.offset);
    } else {
        data.lineLos = null;
    }

    if (uiConfig.showTwo) {
        var reverse = 1;
        if (uiConfig.topDotZero == false) {
            reverse = -1;
        }

        data.lineExps = new Phaser.Geom.Line(
            0, config.offset, 
            //uiConfig.scale * (60000), config.offset);
            // xy
            uiConfig.scale * (2*10000), config.offset+(reverse * (2*38)));
    } else {
        data.lineExps = null;
    }

    if (uiConfig.showRing) {
        data.lineRing1 = new Phaser.Geom.Line(
            0, config.offset, 
            //uiConfig.scale * (60000), config.offset);
            // xy
            uiConfig.scale * (10000), config.offset+96); // 15 moa = 38cm
        data.lineRing2 = new Phaser.Geom.Line(
            0, config.offset, 
            //uiConfig.scale * (60000), config.offset);
            // xy
            uiConfig.scale * (10000), config.offset-96);  // 68moa / 2 = 96cm
    } else {
        data.lineRing1 = null;
        data.lineRing2 = null;
    }

        //this.cameras.main.setBounds(-300, -1000, 60000, 1080);

    // trajectory blocks
    data.trajCurves = [];
    trajs = [
        uiConfig.traj0,
        uiConfig.traj1,
        uiConfig.traj2,
        uiConfig.traj3,
    ];
    for(var i=0; i < trajs.length; i++) {
        if (! trajs[i]) {
            continue;
        }
        makeDots(trajcetories[i].data, uiConfig.trajColorG);

        // trajectory curve
        data.points = [];
        for (var key in trajcetories[i].data) {
            value = trajcetories[i].data[key];

            key = uiConfig.scale * (key * 100);
            value = value * -1 + config.offset;
            data.points.push(new Phaser.Math.Vector2(key, value));
        }
        //data.trajCurves.push(new Phaser.Curves.CubicBezier(data.points));
        data.trajCurves.push(new Phaser.Curves.Spline(data.points));
    }
}


function drawLines(graphics) {
    if (data.showDebug) {
        for (var i = 0; i < data.points.length; i++)
        {
            graphics.fillStyle(0x00ff00, 1);
            graphics.fillCircle(data.points[i].x, data.points[i].y, 4);
        }
    }

    // los, white
    if (data.lineLos != null) {
        graphics.lineStyle(2, uiConfig.colorLosG, 1);
        graphics.strokeLineShape(data.lineLos);
        //graphics.lineBetween(0, config.offset, 
        //    uiConfig.scale * (60000), config.offset);
    }

    // exps, grey-yellow
    if (data.lineExps != null) {
        graphics.lineStyle(2, uiConfig.colorTwoG, 1);
        graphics.strokeLineShape(data.lineExps);
        //graphics.lineBetween(0, config.offset, 
        //    uiConfig.scale * (10000), config.offset+38);
    }

    // ring, grey
    if (data.lineRing1 != null) {
        graphics.lineStyle(2, uiConfig.colorRingG, 1);
        graphics.strokeLineShape(data.lineRing1);
        //graphics.lineBetween(0, config.offset, 
        //    uiConfig.scale * (10000), config.offset+96);
        graphics.strokeLineShape(data.lineRing2);
        //graphics.lineBetween(0, config.offset, 
        //    uiConfig.scale * (10000), config.offset-96);
    }

    // trajectories, red
    graphics.lineStyle(2, uiConfig.trajColorG, 1);
    for(var i=0; i<data.trajCurves.length; i++) {
        data.trajCurves[i].draw(graphics);
    }
}

</script>

</body>
</html>