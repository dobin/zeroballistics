<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.24.1/dist/phaser-arcade-physics.min.js"></script>
    <script src="https://labs.phaser.io/js/datgui.js"></script>
    <script src="gui.js"></script>
    <script src="gfxentities.js"></script>
    <script src="staticdata.js"></script>
</head>
<body>

<script>
// Static Config
var config = {
    type: Phaser.AUTO,
    width: 1440,
    height: 800,
    //backgroundColor: '#788878',
    backgroundColor: '#708e72',
    parent: 'phaser-example',
    scene: {
        preload: preload,
        create: create,
        update: update,
    },

    offset: -84,
    reticleOffsetX: 10000,
};

// The game
var game = null;
var graphics = null;

// Runtime Data
var data = {
    gfxGroup: [],

    lineLos: null,
    lineExps: null,
    lineRing1: null,
    lineRing2: null,

    trajCurves: null,

    points: [],
    showDebug: false,

    reticleEnemy: null,
    reticleEnemyScale: 1.0,

    trajImpactShow: false,
    trajImpactX: 0,
    trajImpactY: 0,
};


// Start here
window.onload = function() {
    initGui();
    new Phaser.Game(config);
    document.getElementsByTagName("canvas").item(0).oncontextmenu = function(e) { e.preventDefault(); e.stopPropagation(); }
};


// Phaser Preload
function preload ()
{
    this.load.image('lemming', '17966.png');
    this.load.image('enemy', '321184.png');
    //this.load.spritesheet('dragcircle', 'assets/sprites/dragcircle.png', { frameWidth: 16 });
}

// Phaser Create
function create()
{
    game = this;
    createGfx(); 

    /* zoom */
    this.cameras.main.zoom = 0.5;
    this.cameras.main.centerOnY(-400);
    this.cameras.main.centerOnX(1100);

    this.input.on('wheel', (pointer, gameObjects, deltaX, deltaY, deltaZ) => {
        //this.cameras.main.centerOn(pointer.worldX, pointer.worldY);

        z = this.cameras.main.zoom;
        if (deltaY < 0) {
            this.cameras.main.zoom += (z/2);
        } else {
            this.cameras.main.zoom -= (z/2);
        }
        //this.cameras.main.centerToBounds();
        //
        //
    });
/*
    this.input.on('pointermove', function (pointer)
    {
        data.pointerWorldX = pointer.worldX;
        //console.log(pointer.worldX, pointer.y);
    }, this);
*/
    /*
    this.input.on('pointerdown', function (pointer) {
        if (data.trajImpactShow) {
            data.trajImpactShow = false;
        } else {
            data.trajImpactShow = true;
        }
//        console.log('down');
//        resetGfx();
    }, this);
    */
}


// Phaser: Update
function update(time, delta)
{
    if (this.reload) {
        this.gfxGroup.forEach(function (item, index) {
            item.destroy();
        });
        createGfx(this);
        this.reload = false;
    }

    handleZoom(this);

    graphics.clear();
    drawLines(graphics);
    drawReticle(graphics);
}


function handleZoom(tt) {
    z = tt.cameras.main.zoom;

    // https://www.html5gamedevs.com/topic/9814-move-camera-by-dragging-the-world-floor/
    // Dragging camera
    if (tt.game.input.activePointer.isDown) {
        if (tt.game.origDragPoint) {
            // move the camera by the amount the mouse has moved since last update
            var sX = tt.game.origDragPoint.x - tt.game.input.activePointer.position.x;
            var sY = tt.game.origDragPoint.y - tt.game.input.activePointer.position.y;

            tt.cameras.main.scrollX += sX / z;
            tt.cameras.main.scrollY += sY / z;
                
        } // set new drag origin to current position
        tt.game.origDragPoint = tt.game.input.activePointer.position.clone();
    } else {
        tt.game.origDragPoint = null;
    }
}


/**************************************/

function resetGfx() {
    data.gfxGroup.forEach(function (item, index) {
            item.destroy();
        });
    createGfx();
}

function createGfx() {
    data.gfxGroup = [];

    // Debug
    if (uiConfig.showDebug) {
        data.gfxGroup.push(game.add.rectangle(
            0, 0, // xy
            1, 200,  // width, height
            0xffffff));
    }

    // Player
    data.gfxGroup.push(game.add.image(-1 * 71, 0, 'lemming'));

    // Enemy
    if (uiConfig.showEnemies) {
        enemyLocations.forEach(function (item, index) {
            if (item == 10 && !uiConfig.show10m) {
                return;
            }
            makeEnemy(item);
            if (item > 0) {
                makeNr(item);
            }
        }.bind(this));
    }

    // ReticleEnemy
    addReticleEnemy();

    // Height indicator
    data.gfxGroup.push(game.add.rectangle(
        -200, 0, // xy
        4, 200,  // width, height
        0xffffff));
    data.gfxGroup.push(game.add.text(
        -250, 110, 
        "2m").setScale(6));

    // Line of sight
    if (uiConfig.showLos) {
        data.lineLos = new Phaser.Geom.Line(
            -50, config.offset, 
            uiConfig.scale * (60000), config.offset);

        arr = {};
        enemyLocations.forEach(element => arr[element] = 0);
        delete(arr[0]);
        makeDots(arr, uiConfig.colorLosG);
    } else {
        data.lineLos = null;
    }

    if (uiConfig.showTwo) {
        var reverse = 1;
        if (uiConfig.topDotZero == false) {
            reverse = -1;
        }

        data.lineExps = new Phaser.Geom.Line(
            0, config.offset, 
            //uiConfig.scale * (60000), config.offset);
            // xy
            uiConfig.scale * (2*10000), config.offset+(reverse * (2*38)));
    } else {
        data.lineExps = null;
    }

    if (uiConfig.showRing) {
        data.lineRing1 = new Phaser.Geom.Line(
            0, config.offset, 
            //uiConfig.scale * (60000), config.offset);
            // xy
            uiConfig.scale * (2*10000), config.offset+(2*96)); // 15 moa = 38cm
        data.lineRing2 = new Phaser.Geom.Line(
            0, config.offset, 
            //uiConfig.scale * (60000), config.offset);
            // xy
            uiConfig.scale * (2*10000), config.offset-(2*96));  // 68moa / 2 = 96cm
    } else {
        data.lineRing1 = null;
        data.lineRing2 = null;
    }

        //this.cameras.main.setBounds(-300, -1000, 60000, 1080);

    // trajectory blocks
    data.trajCurves = [];
    trajs = [
        uiConfig.traj0,
        uiConfig.traj1,
        uiConfig.traj2,
        uiConfig.traj3,
    ];
    for(var i=0; i < trajs.length; i++) {
        if (! trajs[i]) {
            continue;
        }
        makeDots(trajcetories[i].data, uiConfig.trajColorG);

        // trajectory curve
        data.points = [];
        for (var key in trajcetories[i].data) {
            value = trajcetories[i].data[key];

            key = uiConfig.scale * (key * 100);
            value = value * -1 + config.offset;
            data.points.push(new Phaser.Math.Vector2(key, value));
        }
        //data.trajCurves.push(new Phaser.Curves.CubicBezier(data.points));
        data.trajCurves.push(new Phaser.Curves.Spline(data.points));
    }

    /* IMPORTANT to have it here */
    if (graphics != null) {
        graphics.destroy();
    }
    graphics = game.add.graphics();
    graphics.z = 1;
}


function addReticleEnemy() {
    var centerX = config.reticleOffsetX;
    var centerY = -400;

    // Reticle Enemy Picture
    data.reticleEnemy = game.add.image(
        uiConfig.scale * (centerX - 10), 
        centerY + uiConfig.enemyOffset - config.offset, 
        'enemy');
    data.gfxGroup.push(data.reticleEnemy);

    // Reticle Distance Text
    if (data.trajImpactX > 0) {
        data.gfxGroup.push(game.add.text(
            uiConfig.scale * (centerX-210), 
            centerY+200, 
            data.trajImpactX)
        );
    }
}

function drawReticle(graphics) {
    var centerX = uiConfig.scale * config.reticleOffsetX;
    var centerY = -400;
    var dotOffset = 38; // 15moa in cm

    var color = 0xffff00;
    var thickness = 4;
    var alpha = 1;

    graphics.lineStyle(thickness, uiConfig.colorRingG, alpha);
    var a = new Phaser.Geom.Point(centerX, centerY);
    var radius = 86; // 68 moa / 2 in cm
    graphics.strokeCircle(a.x, a.y, radius*data.reticleEnemyScale);

    graphics.fillStyle(uiConfig.colorLosG, 1.0);
    graphics.fillRect(centerX-2, centerY-2, 4, 4);

    if (uiConfig.showTwo) {
        graphics.fillStyle(uiConfig.colorTwoG, 1.0);
        graphics.fillRect(centerX-2, centerY-2 + data.reticleEnemyScale*dotOffset, 4, 4);
    }

    if (data.trajImpactShow) {
        var r1 = 8;
        var r2 = 4;

        /* on trajectory */
        graphics.fillStyle(uiConfig.trajColorG, 1.0);
        graphics.fillRect(
            uiConfig.scale * ((data.trajImpactX*100)) - (r1/2), 
            (data.trajImpactY * -1 + config.offset) - (r1/2), 
            r1, 
            r1);

        /* on reticle */
        graphics.fillStyle(uiConfig.trajColorG, 1.0);
        graphics.fillRect(
            centerX - (r2/2), 
            centerY - (r2/2) - data.trajImpactY, 
            r2, 
            r2);
    }
}

function drawLines(graphics) {
    if (data.showDebug) {
        for (var i = 0; i < data.points.length; i++)
        {
            graphics.fillStyle(0x00ff00, 1);
            graphics.fillCircle(data.points[i].x, data.points[i].y, 4);
        }
    }

    // los, white
    if (data.lineLos != null) {
        graphics.lineStyle(2, uiConfig.colorLosG, 1);
        graphics.strokeLineShape(data.lineLos);
        //graphics.lineBetween(0, config.offset, 
        //    uiConfig.scale * (60000), config.offset);
    }

    // exps, grey-yellow
    if (data.lineExps != null) {
        graphics.lineStyle(2, uiConfig.colorTwoG, 1);
        graphics.strokeLineShape(data.lineExps);
        //graphics.lineBetween(0, config.offset, 
        //    uiConfig.scale * (10000), config.offset+38);
    }

    // ring, grey
    if (data.lineRing1 != null) {
        graphics.lineStyle(2, uiConfig.colorRingG, 1);
        graphics.strokeLineShape(data.lineRing1);
        //graphics.lineBetween(0, config.offset, 
        //    uiConfig.scale * (10000), config.offset+96);
        graphics.strokeLineShape(data.lineRing2);
        //graphics.lineBetween(0, config.offset, 
        //    uiConfig.scale * (10000), config.offset-96);
    }

    // trajectories, red
    graphics.lineStyle(2, uiConfig.trajColorG, 1);
    for(var i=0; i<data.trajCurves.length; i++) {
        data.trajCurves[i].draw(graphics);
    }
}

</script>

</body>
</html>